<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://webslides.tv/static/css/webslides.css">
  <link rel="stylesheet" href="https://webslides.tv/static/css/svg-icons.css">
  <title>alexhatchl — portfolio</title>
</head>
<body>
<main role="main">
  <article id="webslides">
  <section class="fullscreen aligncenter" id="pixel-rain-intro">
  <style>
    #pixel-rain-intro { background:#fff; }
    #pixel-rain-intro .stage{
      position:absolute; inset:0; width:100%; height:100%;
      display:block; image-rendering:pixelated; image-rendering:crisp-edges;
    }
    #pixel-rain-intro .overlay{
      position:relative; z-index:3; height:100%;
      display:grid; place-items:center; color:#000;
    }
    #pixel-rain-intro h1{ margin:0; font-size:4rem; letter-spacing:.06em; }
    #pixel-rain-intro .loading{
      position:absolute; bottom:24px; left:24px; color:#666; font-size:.9rem; z-index:4;
    }
    @media (max-width:720px){ #pixel-rain-intro h1{ font-size:2.6rem; } }
  </style>

  <canvas class="stage" id="px-bg"></canvas>
  <canvas class="stage" id="px-rain" style="z-index:2;"></canvas>
  <div class="overlay"><h1>alexhatchl</h1></div>
  <div class="loading" id="px-load">lädt…</div>

  <script>
  (function(){
    const section = document.getElementById('pixel-rain-intro');
    const bg = document.getElementById('px-bg'), rg = document.getElementById('px-rain');
    const bgx = bg.getContext('2d', {alpha:false}), rgx = rg.getContext('2d', {alpha:true});
    bgx.imageSmoothingEnabled = false; rgx.imageSmoothingEnabled = false;

    // Bild (lokal im Repo):
    const SOURCE = 'images/window-city.jpg?v=' + Date.now(); // Cache-Buster

    // Pixelizer-Settings
    const PIX_WIDTH = 320;      // Breite des Pixelrasters
    const USE_4_LEVELS = true;  // 4 Graustufen; per Taste B auf 2 Levels umschaltbar
    let   showPixel = true;     // Taste P toggelt original/pixel

    // Regen-Settings
    const COLS_BASE = 64;

    const pxload = document.getElementById('px-load');

    function fit(){
      const r = section.getBoundingClientRect();
      bg.width = Math.max(2, Math.floor(r.width));
      bg.height= Math.max(2, Math.floor(r.height));
      rg.width = bg.width;
      rg.height= bg.height;
      bgx.fillStyle = '#fff'; bgx.fillRect(0,0,bg.width,bg.height);
      if (img.complete) render();
    }
    new ResizeObserver(fit).observe(section); fit();

    const img = new Image();
    img.onload = ()=>{ pxload.style.display='none'; render(); };
    img.onerror = ()=>{ pxload.textContent='Bild nicht gefunden: images/window-city.jpg'; };
    img.src = SOURCE;

    // ---- Pixelizer mit Auto-Kontrast (Histogramm-Stretch zwischen P5..P95) ----
    function grayscale(imgData){
      const d = imgData.data;
      const g = new Uint8ClampedArray(d.length/4);
      for(let i=0,j=0;i<d.length;i+=4,++j){
        g[j] = (0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2])|0;
      }
      return g;
    }
    function histStretch(g){
      // Perzentile 5..95
      const hist = new Uint32Array(256);
      for(const v of g) hist[v]++;
      let cum=0, p5=0, p95=255, total=g.length;
      for(let i=0;i<256;i++){ cum+=hist[i]; if(cum>=total*0.05){ p5=i; break; } }
      cum=0;
      for(let i=255;i>=0;i--){ cum+=hist[i]; if(cum>=total*0.05){ p95=i; break; } }
      const range = Math.max(1, p95 - p5);
      const lut = new Uint8Array(256);
      for(let i=0;i<256;i++){
        let v = ( (i - p5) * 255 / range );
        if (v<0) v=0; if (v>255) v=255;
        lut[i]=v|0;
      }
      for(let i=0;i<g.length;i++) g[i]=lut[g[i]];
      return g;
    }
    function quantize(g, levels){ // levels = 2 oder 4
      const out = new Uint8ClampedArray(g.length);
      if(levels===2){
        for(let i=0;i<g.length;i++){ out[i] = (g[i]<128)?0:255; }
      }else{ // 4 Level
        for(let i=0;i<g.length;i++){
          const v=g[i];
          out[i] = (v<64)?0 : (v<128)?85 : (v<192)?170 : 255;
        }
      }
      return out;
    }
    function drawPixelized(){
      const ratio = img.height/img.width;
      const w = PIX_WIDTH, h = Math.round(w * ratio);
      const small = document.createElement('canvas');
      small.width=w; small.height=h;
      const sx = small.getContext('2d'); sx.imageSmoothingEnabled=false;
      sx.drawImage(img,0,0,w,h);
      const id = sx.getImageData(0,0,w,h);
      let g = grayscale(id);
      g = histStretch(g);  // ← macht den grauen Schleier weg, hebt Kontraste
      const q = quantize(g, USE_4_LEVELS?4:2);
      // zurück in ImageData
      const d = id.data;
      for(let i=0,j=0;i<d.length;i+=4,++j){
        const v = q[j]; d[i]=d[i+1]=d[i+2]=v; d[i+3]=255;
      }
      sx.putImageData(id,0,0);
      drawCover(bgx, small);
    }
    function drawOriginal(){
      // original (ohne Pixelizer) – zum Gegencheck
      drawCover(bgx, img);
    }
    function drawCover(ctx, src){
      const W=ctx.canvas.width,H=ctx.canvas.height;
      let sw,sh;
      if(src instanceof HTMLImageElement){ sw=src.naturalWidth; sh=src.naturalHeight; }
      else { sw=src.width; sh=src.height; }
      const sR=sw/sh, tR=W/H;
      let dw=W, dh=Math.round(W/sR);
      if(dh<H){ dh=H; dw=Math.round(H*sR); }
      const dx=Math.round((W-dw)/2), dy=Math.round((H-dh)/2);
      ctx.imageSmoothingEnabled=false;
      ctx.fillStyle='#fff'; ctx.fillRect(0,0,W,H);
      ctx.drawImage(src,0,0,sw,sh,dx,dy,dw,dh);
    }
    function render(){
      if(showPixel) drawPixelized();
      else drawOriginal();
    }

    // ---- Regen (leicht, performant) ----
    let COLS = COLS_BASE;
    function density(){ // abhängig von Breite
      COLS = Math.max(36, Math.min(120, Math.round(bg.width / 18)));
    }
    density();
    let streaks = Array.from({length:COLS},(_,i)=>({
      xNorm:(i+Math.random()*0.5)/COLS, y:Math.random(),
      v:0.18+Math.random()*0.32, len:0.06+Math.random()*0.22, wob:Math.random()*0.5+0.15
    }));

    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.05, (now-last)/1000); last=now;
      const W=rg.width, H=rg.height;
      rgx.clearRect(0,0,W,H);
      rgx.fillStyle='#000';
      for(const s of streaks){
        const x = Math.round(s.xNorm*W + Math.sin(now*0.0009+s.xNorm*10)*s.wob*6);
        const y = s.y*H, L = Math.round(s.len*H);
        for(let k=0;k<L;k+=2){
          const yy=(y+k)|0;
          if(yy>=0 && yy<H){
            rgx.fillRect(x,yy,1,1);
            if((k%6)===0){ if(x+1<W)rgx.fillRect(x+1,yy,1,1); if(x-1>=0)rgx.fillRect(x-1,yy,1,1); }
          }
        }
        rgx.fillRect(x-1, (y+L+1)|0, 3, 2);
        s.y += s.v*dt;
        if(s.y*H > H+12){ s.y = -Math.random()*0.2; s.len=0.06+Math.random()*0.22; s.v=0.18+Math.random()*0.32; }
      }
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // Events
    window.addEventListener('resize', ()=>{
      fit(); density();
      streaks = Array.from({length:COLS},(_,i)=>({
        xNorm:(i+Math.random()*0.5)/COLS, y:Math.random(),
        v:0.18+Math.random()*0.32, len:0.06+Math.random()*0.22, wob:Math.random()*0.5+0.15
      }));
    }, {passive:true});

    // Tastatur: P = Pixel/Original, B = 4/2 Levels
    window.addEventListener('keydown', (e)=>{
      if(e.key.toLowerCase()==='p'){ showPixel=!showPixel; render(); }
      if(e.key.toLowerCase()==='b'){ window.USE_4_LEVELS = !window.USE_4_LEVELS; render(); }
    });
  })();
  </script>
</section>

  </article>
</main>
<script src="https://webslides.tv/static/js/webslides.js"></script>
<script>window.ws=new WebSlides();</script>
<script defer src="https://webslides.tv/static/js/svg-icons.js"></script>
</body>
</html>
