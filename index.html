<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://webslides.tv/static/css/webslides.css">
  <link rel="stylesheet" href="https://webslides.tv/static/css/svg-icons.css">
  <title>alexhatchl — portfolio</title>
</head>
<body>
<main role="main">
  <article id="webslides">
 <!-- B/W PIXEL-ART: WINDOW RAIN WITH BLURRY CITY -->
<section class="fullscreen aligncenter" id="bw-rain-window">
  <style>
    #bw-rain-window { background:#fff; }
    #bw-rain-window canvas{
      position:absolute; inset:0; width:100%; height:100%;
      display:block; pointer-events:none;
      image-rendering: pixelated; image-rendering: crisp-edges;
    }
  </style>
  <canvas></canvas>

  <script>
  (function(){
    const section = document.getElementById('bw-rain-window');
    const cvs = section.querySelector('canvas');
    const ctx = cvs.getContext('2d', { alpha:false });
    ctx.imageSmoothingEnabled = false;

    // Low-res Arbeitsfläche (wird via CSS groß skaliert)
    const W = 192, H = 108; // 16:9
    cvs.width = W; cvs.height = H;

    // ---------- Helpers ----------
    function dot(x,y){ ctx.fillRect(x|0, y|0, 1, 1); }
    function rect(x,y,w,h,c='#000'){ ctx.fillStyle=c; ctx.fillRect(x|0,y|0,w|0,h|0); }

    // Dithering: level 0..5 (0=weiß → kaum Punkte, 5=dunkel → viele Punkte)
    function ditherRect(x,y,w,h,level=2,phase=0){
      const clamp = (n,min,max)=>Math.max(min,Math.min(max,n|0));
      level = clamp(level,0,7);
      const thr = [-1,0,1,2,3,4,5,6][level]; // 8x8 Bayer-artiges Raster
      for(let j=0;j<h;j++){
        for(let i=0;i<w;i++){
          const m = (i + j + phase) & 7; // 0..7
          if(m <= thr) dot(x+i, y+j);
        }
      }
    }

    // ---------- Stadt (verschwommen angedeutet) ----------
    const farLayer = [], nearLayer = [];
    function buildCity(){
      farLayer.length = 0; nearLayer.length = 0;
      // Ferne Silhouetten (helles Dither)
      let x = 0;
      while(x < W){
        const bw = 8 + (Math.random()*10|0);
        const bh = 20 + (Math.random()*30|0);
        farLayer.push({x, y:H-40-bh, w:bw, h:bh});
        x += bw + (Math.random()*4|0);
      }
      // Nahe Silhouetten (dunkler)
      x = 0;
      while(x < W){
        const bw = 10 + (Math.random()*14|0);
        const bh = 18 + (Math.random()*34|0);
        nearLayer.push({x, y:H-30-bh, w:bw, h:bh});
        x += bw + (Math.random()*6|0);
      }
    }
    buildCity();

    function drawCity(t){
      // „Nebel“/Himmel leicht gedithert
      ditherRect(0, 0, W, 48, 0, (t/120|0)%8);

      // Ferne Gebäude (weiches Dither + minimale Unschärfe via 2. Overlay)
      for(const b of farLayer){
        ditherRect(b.x, b.y, b.w, b.h, 1, (t/90|0)%8);
        ditherRect(b.x+1, b.y+1, b.w, b.h, 0, (t/120|0+2)%8);
      }
      // Nahe Gebäude
      for(const b of nearLayer){
        ditherRect(b.x, b.y, b.w, b.h, 3, (t/70|0)%8);
      }

      // Horizont / Boden leicht andeuten
      ditherRect(0, H-26, W, 4, 1, (t/60|0)%8);
    }

    // ---------- Regen auf der Scheibe (vertikale Läufer + Tropfen) ----------
    const COLS = 48;              // Anzahl „Glaskolonnen“
    const streaks = [];
    for(let i=0;i<COLS;i++){
      streaks.push({
        x: ((i + Math.random()*0.5) / COLS) * W,
        y: Math.random()*H,
        v: 0.4 + Math.random()*0.8, // Geschwindigkeit
        len: 6 + (Math.random()*16|0), // Länge des Läufers
        wob: Math.random()*0.6 + 0.2   // seitliches Wabern
      });
    }

    function drawRain(t){
      // Mikro-Kondenswasser („Fogged glass“) — sehr feines Dither vorne
      ditherRect(0, 0, W, H, 0, (t/40|0)%8);

      // Läufer + Tropfen (schwarze 1px-„Tinte“ auf weißem Glas)
      ctx.fillStyle = '#000';
      for(const s of streaks){
        // leichtes seitliches Wabern
        const drift = Math.sin((t*0.002) + s.x*0.1) * s.wob;
        // Hauptstrich
        for(let k=0;k<s.len;k++){
          const yy = (s.y + k) % (H+8);
          const xx = Math.max(0, Math.min(W-1, s.x + drift));
          dot(xx|0, yy|0);
          // kleine Schatten rechts/links (schwächer, per Dither simuliert)
          if(k % 3 === 0){
            if(xx+1 < W) ditherRect((xx+1)|0, yy|0, 1, 1, 1, k&7);
            if(xx-1 >=0) ditherRect((xx-1)|0, yy|0, 1, 1, 1, (k+4)&7);
          }
        }
        // Kopf-Tropfen (dicker Punkt)
        rect((s.x+drift-1)|0, (s.y+s.len)|0, 3, 2, '#000');

        // Bewegung aktualisieren
        s.y += s.v;
        if(s.y > H+12){
          s.y = -Math.random()*40;          // neu von oben
          s.len = 6 + (Math.random()*16|0); // neue Länge
          s.v = 0.4 + Math.random()*0.8;    // neue Geschwindigkeit
        }
      }
    }

    // ---------- Frame Loop ----------
    function frame(t){
      // Weißes Glas „reinigen“
      ctx.fillStyle = '#fff'; ctx.fillRect(0,0,W,H);

      drawCity(t);
      drawRain(t);

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    // Robust bei Größenwechsel (Canvas bleibt Low-Res; CSS skaliert)
    const ro = new ResizeObserver(()=>{ /* no-op */ });
    ro.observe(section);
    document.addEventListener('ws:slide-change', ()=>{ /* no-op */ });
  })();
  </script>
</section>



  </article>
</main>
<script src="https://webslides.tv/static/js/webslides.js"></script>
<script>window.ws=new WebSlides();</script>
<script defer src="https://webslides.tv/static/js/svg-icons.js"></script>
</body>
</html>
