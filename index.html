<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>alexhatchl — kinetic grid</title>

  <!-- Smooth fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Work+Sans:wght@500;700&family=Inter:wght@600&display=swap" rel="stylesheet">

  <style>
    :root{
      --hint-bg: rgba(17,17,17,.75);
      --hint-fg: #fff;
      --accent:  #00a6ff;
    }
    html,body{height:100%;margin:0;background:#f4f4f4}
    /* Pixel layer (background grid) */
    canvas#stage{
      position:fixed; inset:0; width:100vw; height:100vh; z-index:1;
      image-rendering: pixelated; image-rendering: crisp-edges; display:block;
    }
    /* UI overlays drawn above, including smooth text layer */
    canvas#ui{
      position:fixed; inset:0; width:100vw; height:100vh; z-index:2;
      display:block; pointer-events:none;
    }

    /* Arrow hint */
    .hint{
      position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
      z-index:5; background:var(--hint-bg); color:var(--hint-fg);
      font:14px/1.35 "Work Sans", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      padding:10px 14px; border-radius:10px; letter-spacing:.02em;
      display:flex; align-items:center; gap:10px; user-select:none;
    }
    .keys{
      display:inline-flex; gap:6px; align-items:center;
    }
    .key{
      min-width:20px; height:20px; padding:0 6px;
      border:1px solid rgba(255,255,255,.4);
      border-bottom-width:2px; border-radius:6px;
      display:inline-flex; align-items:center; justify-content:center;
      font:12px/1 "Inter", system-ui, sans-serif;
      background:rgba(255,255,255,.1);
    }

    /* Help panel (toggle with H/?) */
    .panel{
      position:fixed; right:18px; bottom:18px; z-index:6;
      width:min(92vw,420px); max-width:420px;
      background:var(--hint-bg); color:var(--hint-fg);
      border-radius:12px; padding:14px 16px; box-shadow:0 8px 24px rgba(0,0,0,.2);
      font:14px/1.45 "Work Sans", system-ui, sans-serif; display:none;
    }
    .panel h3{margin:0 0 10px; font:700 16px/1.2 "Work Sans", system-ui, sans-serif}
    .panel .row{display:flex; justify-content:space-between; gap:8px; margin:6px 0}
    .panel .row .left{opacity:.9}
    .panel .row .right{display:flex; gap:6px}
    .panel .key{border-color:rgba(255,255,255,.35)}
    .badge{
      display:inline-block; padding:2px 8px; border-radius:999px;
      background:rgba(255,255,255,.12); font:12px/1.2 "Inter", system-ui, sans-serif;
    }

    /* Mini status bubble (top-left) */
    .status{
      position:fixed; left:10px; top:10px; z-index:7;
      background:var(--hint-bg); color:var(--hint-fg);
      font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      padding:6px 8px; border-radius:8px; display:none;
    }
  </style>
</head>
<body>

<!-- Pixel grid -->
<canvas id="stage"></canvas>
<!-- Smooth overlay for text and UI drawing -->
<canvas id="ui"></canvas>

<!-- Arrow-keys hint -->
<div class="hint" id="hint">
  <span class="keys">
    <span class="key">←</span><span class="key">→</span>
  </span>
  <span>mit den Pfeiltasten navigieren</span>
  <span class="keys" style="margin-left:10px">
    <span class="key">H</span>
  </span>
  <span>Hilfe</span>
</div>

<!-- Help panel -->
<div class="panel" id="panel">
  <h3>Steuerung</h3>
  <div class="row"><span class="left">Pause / Weiter</span><span class="right"><span class="key">Space</span></span></div>
  <div class="row"><span class="left">Neues Layout</span><span class="right"><span class="key">R</span></span></div>
  <div class="row"><span class="left">Farben neu mischen</span><span class="right"><span class="key">C</span></span></div>
  <div class="row"><span class="left">Pixelgröße</span><span class="right"><span class="key">B</span></span></div>
  <div class="row"><span class="left">Schrift wechseln</span><span class="right"><span class="key">F</span></span></div>
  <div class="row"><span class="left">Hilfe ein/aus</span><span class="right"><span class="key">H</span><span class="key">?</span></span></div>
  <div class="row" style="margin-top:8px"><span class="badge">Tipp</span><span class="left" style="opacity:.85">Klick auf diese Box schließt sie.</span></div>
</div>

<!-- debug/status (shown only when needed) -->
<div class="status" id="status"></div>

<script>
(() => {
  // ---------- canvases ----------
  const stage = document.getElementById('stage');
  const stx   = stage.getContext('2d', {alpha:false});
  stx.imageSmoothingEnabled = false;

  const ui = document.getElementById('ui');
  const utx = ui.getContext('2d', {alpha:true});
  utx.imageSmoothingEnabled = true; // smooth text!

  // offscreen buffer for pixel grid
  const buf = document.createElement('canvas');
  const btx = buf.getContext('2d', {alpha:false});
  btx.imageSmoothingEnabled = false;

  // ---------- state ----------
  let PIX = 4;
  let paused = false;
  let fontIndex = 0; // cycles through fonts
  const FONTS = [
    `"Work Sans", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`,
    `"Inter", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`
  ];

  // arrow hint & help panel
  const hint  = document.getElementById('hint');
  const panel = document.getElementById('panel');
  panel.addEventListener('click', ()=> panel.style.display='none');

  function showStatus(txt){
    const el = document.getElementById('status');
    el.textContent = txt;
    el.style.display = 'block';
    clearTimeout(showStatus._t);
    showStatus._t = setTimeout(()=> el.style.display='none', 1600);
  }

  function resize(){
    // stage & ui canvas scale to window
    stage.width  = Math.max(2, Math.floor(window.innerWidth));
    stage.height = Math.max(2, Math.floor(window.innerHeight));
    ui.width  = stage.width;
    ui.height = stage.height;

    const d = Math.min(stage.width, stage.height);
    PIX = d < 800 ? 3 : 4;

    buf.width  = Math.ceil(stage.width  / PIX);
    buf.height = Math.ceil(stage.height / PIX);

    // initial paint (paper + tiny test bar) so you see something instantly
    btx.fillStyle = '#F6F6F6'; btx.fillRect(0,0,buf.width,buf.height);
    btx.fillStyle = '#ff3b30'; btx.fillRect(4,4,Math.min(60,buf.width-8),10);
    stx.clearRect(0,0,stage.width,stage.height);
    stx.drawImage(buf,0,0,buf.width,buf.height,0,0,stage.width,stage.height);
    utx.clearRect(0,0,ui.width,ui.height);
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // ---------- colors ----------
  const COLORS = { white:'#FFFFFF', red:'#E6432E', yellow:'#F4D21F', blue:'#1A3D9A', black:'#111111' };
  const PALETTE = [COLORS.white, COLORS.red, COLORS.yellow, COLORS.blue];
  function pickColor(){
    const r=Math.random();
    return r<.64?COLORS.white : r<.80?COLORS.red : r<.92?COLORS.yellow : COLORS.blue;
  }
  function otherColor(base){
    const c = PALETTE.filter(x=>x!==base);
    return c[(Math.random()*c.length)|0];
  }

  // ---------- layout ----------
  let vLines,hLines,vCur,vTarget,hCur,hTarget,cells;

  function seedLayout(){
    const nV = 3 + (Math.random()*3|0);
    const nH = 3 + (Math.random()*3|0);
    const randPos = n=>{
      const s=new Set();
      while(s.size<n) s.add(Math.round((0.12+Math.random()*0.76)*1000)/1000);
      return [...s].sort((a,b)=>a-b);
    };
    vLines=[0,...randPos(nV),1];
    hLines=[0,...randPos(nH),1];
    vCur=vLines.slice(); vTarget=vLines.slice();
    hCur=hLines.slice(); hTarget=hLines.slice();

    cells=[];
    for(let j=0;j<hLines.length-1;j++){
      const row=[];
      for(let i=0;i<vLines.length-1;i++) row.push(pickColor());
      cells.push(row);
    }
    bindTextRow();
  }

  // ---------- letter groups in one row ----------
  const WORD='alexhatchl';
  let textRowIndex=0, groups=[];
  function bindTextRow(){
    const rows = hLines.length-1;
    textRowIndex = Math.max(0, Math.min(rows-1, (rows/2)|0));
    groups = WORD.split('');
    fitGroupsToCols();
  }
  function fitGroupsToCols(){
    const cols = vLines.length-1;
    while(groups.length>cols){
      const i = 1 + (Math.random()*(groups.length-1)|0);
      groups[i-1]+=groups[i]; groups.splice(i,1);
    }
    while(groups.length<cols){
      const idx = groups.findIndex(g=>g.length>1);
      if(idx===-1){ groups.push(''); break; }
      const g=groups[idx], cut=1+(Math.random()*(g.length-1)|0);
      groups.splice(idx,1,g.slice(0,cut),g.slice(cut));
    }
  }
  function mutateGroups(){
    if(groups.length<=1 || Math.random()<.5){
      const idxs=[]; for(let i=0;i<groups.length;i++) if(groups[i].length>1) idxs.push(i);
      if(idxs.length){
        const i = idxs[(Math.random()*idxs.length)|0];
        const g = groups[i], cut = 1+(Math.random()*(g.length-1)|0);
        groups.splice(i,1,g.slice(0,cut),g.slice(cut));
      }
    }else if(groups.length>=2){
      const i = 1 + (Math.random()*(groups.length-1)|0);
      groups[i-1]+=groups[i]; groups.splice(i,1);
    }
    fitGroupsToCols();
  }

  // ---------- motion ----------
  const MIN_GAP=.08, STEP=.04, COUPLE=.55, EASE=.14;
  let nextBeatA=0, nextBeatB=0;

  const clamp = (v,a,b)=> v<a?a : (v>b?b : v);
  function nudge(target, index, dir){
    const i=index, L=i-1, R=i+1, step=dir*STEP;
    const minX = target[L]+MIN_GAP, maxX = target[R]-MIN_GAP;
    target[i] = clamp(target[i] + step, minX, maxX);
    if(L>0){
      const lmin=target[L-1]+MIN_GAP, lmax=target[i]-MIN_GAP;
      target[L] = clamp(target[L] + step*COUPLE, lmin, lmax);
    }
    if(R < target.length-1){
      const rmin=target[i]+MIN_GAP, rmax=target[R+1]-MIN_GAP;
      target[R] = clamp(target[R] + step*COUPLE, rmin, rmax);
    }
  }
  function recolor(){
    for(let j=0;j<cells.length;j++)
      for(let i=0;i<cells[j].length;i++)
        if(Math.random()<.28) cells[j][i]=pickColor();
  }
  function beat(){
    if(Math.random()<.5){
      if(vTarget.length>2) nudge(vTarget, 1+(Math.random()*(vTarget.length-2)|0), Math.random()<.5?-1:1);
    }else{
      if(hTarget.length>2) nudge(hTarget, 1+(Math.random()*(hTarget.length-2)|0), Math.random()<.5?-1:1);
    }
    if(Math.random()<.18) recolor();
    if(Math.random()<.9) mutateGroups();
  }
  const lerpTowards=(cur,tgt,k)=>{ for(let i=0;i<cur.length;i++) cur[i]+= (tgt[i]-cur[i])*k; };

  // ---------- draw ----------
  function draw(){
    const W=buf.width, H=buf.height;
    btx.fillStyle='#F6F6F6'; btx.fillRect(0,0,W,H);
    // cells
    for(let j=0;j<hCur.length-1;j++){
      const y0=Math.round(hCur[j]*H), y1=Math.round(hCur[j+1]*H);
      for(let i=0;i<vCur.length-1;i++){
        const x0=Math.round(vCur[i]*W), x1=Math.round(vCur[i+1]*W);
        btx.fillStyle=cells[j][i];
        btx.fillRect(x0,y0,x1-x0,y1-y0);
      }
    }
    // lines
    const L=Math.max(2, Math.round(Math.min(W,H)*0.008));
    btx.fillStyle=COLORS.black;
    for(let i=0;i<vCur.length;i++){ const x=Math.round(vCur[i]*W)-(L>>1); btx.fillRect(x,0,L,H); }
    for(let j=0;j<hCur.length;j++){ const y=Math.round(hCur[j]*H)-(L>>1); btx.fillRect(0,y,W,L); }

    // push pixel buffer to screen
    stx.imageSmoothingEnabled=false;
    stx.clearRect(0,0,stage.width,stage.height);
    stx.drawImage(buf,0,0,W,H,0,0,stage.width,stage.height);

    // draw SMOOTH text on the UI canvas (after scaling)
    utx.clearRect(0,0,ui.width,ui.height);
    const cols=vCur.length-1;
    if(groups.length!==cols) fitGroupsToCols();
    const ry0=Math.round(hCur[textRowIndex]*H), ry1=Math.round(hCur[textRowIndex+1]*H);
    // map buffer Y -> screen Y
    const y0 = Math.round(ry0 * (stage.height / H));
    const y1 = Math.round(ry1 * (stage.height / H));
    const cy = (y0 + y1) >> 1;

    const fontPx = Math.max(12, Math.round(Math.min(stage.width,stage.height) * 0.018));
    utx.font = `600 ${fontPx}px ${FONTS[fontIndex]}`;
    utx.textAlign='center'; utx.textBaseline='middle';

    for(let i=0;i<cols;i++){
      const g = groups[i] || ''; if(!g) continue;
      const x0b = Math.round(vCur[i]*W), x1b = Math.round(vCur[i+1]*W);
      const x0s = Math.round(x0b * (stage.width / W));
      const x1s = Math.round(x1b * (stage.width / W));
      const cx  = (x0s + x1s) >> 1;
      utx.fillStyle = otherColor(cells[textRowIndex][i]);
      utx.fillText(g, cx, cy);
    }
  }

  // ---------- run ----------
  function start(){
    seedLayout();
    draw(); // visible at once
    let t0 = performance.now();
    function loop(now){
      if(!paused){
        const t=(now-t0)/1000;
        lerpTowards(vCur,vTarget,.14);
        lerpTowards(hCur,hTarget,.14);
        if(t>=nextBeatA){ beat(); nextBeatA = t + (0.85 + (Math.random()*0.16 - 0.08)); }
        if(t>=nextBeatB){ beat(); nextBeatB = t + (1.38 + (Math.random()*0.22 - 0.11)); }
        draw();
      }
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  }
  start();

  // ---------- keys ----------
  window.addEventListener('keydown', (e)=>{
    const k=e.key.toLowerCase();
    if(k===' '){ paused=!paused; showStatus(paused?'pause':'play'); }
    if(k==='r'){ seedLayout(); draw(); showStatus('layout'); }
    if(k==='c'){ recolor(); draw(); showStatus('colors'); }
    if(k==='b'){
      PIX = (PIX===4)?6:(PIX===6?3:4);
      buf.width=Math.ceil(stage.width/PIX); buf.height=Math.ceil(stage.height/PIX);
      draw(); showStatus('pixel '+PIX);
    }
    if(k==='f'){
      fontIndex = (fontIndex+1) % FONTS.length;
      draw(); showStatus('font '+(fontIndex+1));
    }
    if(k==='h' || k==='?' ){
      panel.style.display = (panel.style.display==='block') ? 'none' : 'block';
    }
  });

  // hide hint after a few seconds
  setTimeout(()=> hint.style.display='none', 5000);
})();
</script>
</body>
</html>
