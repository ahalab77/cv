<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>alexhatchl — pixel water</title>
  <style>
    html,body{
      height:100%; margin:0; background:#0a0c20;
      overflow:hidden; /* echtes Fullscreen-Canvas */
    }
    canvas{
      position:fixed; inset:0; width:100%; height:100%;
      display:block;
      /* wichtig für den Pixel-Look: */
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    .center {
      position:fixed; inset:0; display:grid; place-items:center;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:#ffffff; text-shadow:0 2px 6px rgba(0,0,0,.7);
      pointer-events:none; letter-spacing:.06em; font-size:clamp(28px, 6vw, 64px);
    }
  </style>
</head>
<body>
  <canvas id="view"></canvas>
  <div class="center">alexhatchl</div>

  <script>
  (function(){
    const IMG_SRC = 'images/BG.png';   // <-- dein Bild

    // Pixel-Parameter (kannst du anpassen)
    const PIXEL_SIZE_DESKTOP = 4;      // je größer, desto „blockiger“
    const PIXEL_SIZE_MOBILE  = 3;

    // Wellen-Parameter
    const WAVE_AMP   = 0.02;           // Amplitude relativ zur Bildbreite (0.0–0.05 ist gut)
    const WAVE_FREQ  = 10;             // wie „eng“ die Wellen sind
    const WAVE_SPEED = 0.6;            // Geschwindigkeit

    const canvas = document.getElementById('view');
    const ctx    = canvas.getContext('2d', {alpha:false, desynchronized:true});
    ctx.imageSmoothingEnabled = false;

    // Offscreen-Buffer (Low-Res → Pixel-Look)
    const buf    = document.createElement('canvas');
    const bufx   = buf.getContext('2d', {alpha:false});
    bufx.imageSmoothingEnabled = false;

    // Bild laden
    const img = new Image();
    img.onload = () => { fit(); start(); };
    img.onerror = () => {
      // Fallback, falls Bild fehlt
      ctx.fillStyle = '#222'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#fff'; ctx.fillText('BG.png nicht gefunden', 20, 40);
    };
    img.src = IMG_SRC + '?v=' + Date.now(); // Cache-Buster

    // Größen/Buffer anpassen
    function fit(){
      const W = canvas.width  = Math.max(2, window.innerWidth);
      const H = canvas.height = Math.max(2, window.innerHeight);

      const pixelSize = (Math.min(W,H) < 820) ? PIXEL_SIZE_MOBILE : PIXEL_SIZE_DESKTOP;
      buf.width  = Math.ceil(W / pixelSize);
      buf.height = Math.ceil(H / pixelSize);
    }
    window.addEventListener('resize', fit, {passive:true});

    // „cover“: berechne Quellrechteck im Bild, das den Buffer vollständig füllt
    function computeCoverRect(srcW, srcH, dstW, dstH){
      const sR = srcW/srcH, dR = dstW/dstH;
      let sw, sh, sx, sy;
      if (sR > dR){ // Quelle „zu breit“ → in der Breite beschneiden
        sh = srcH; sw = Math.round(sh * dR);
        sx = Math.round((srcW - sw)/2); sy = 0;
      } else {     // Quelle „zu hoch“ → in der Höhe beschneiden
        sw = srcW; sh = Math.round(sw / dR);
        sx = 0; sy = Math.round((srcH - sh)/2);
      }
      return {sx, sy, sw, sh};
    }

    // Eine Frame-Zeile in den Low-Res-Buffer schreiben (mit horizontaler Wellenversatz)
    function drawWaveRow(y, t, cover){
      const dstW = buf.width,  dstH = buf.height;
      const srcW = cover.sw,   srcH = cover.sh;

      // korrespondierende y-Position im Quellbild:
      const sy = cover.sy + (y / dstH) * srcH;

      // horizontale Verschiebung (Quelle) für diese Zeile:
      const phase = (y / dstH) * WAVE_FREQ + t * WAVE_SPEED;
      const shift = Math.sin(phase) * (WAVE_AMP * srcW); // in Quellpixeln

      // Quell-x mit Clamp (keine Ränder „leer“)
      let sx = Math.round(cover.sx + shift);
      if (sx < cover.sx) sx = cover.sx;
      if (sx > cover.sx + srcW - 1) sx = cover.sx + srcW - 1;

      // Wir ziehen eine 1-Pixel hohe Zeile aus der Quelle auf die gesamte Zielbreite
      // und schreiben sie in eine 1-Pixel hohe Zeile im Buffer:
      bufx.drawImage(
        img,
        sx, Math.floor(sy), Math.max(1, srcW - (sx - cover.sx)), 1, // src (Zeile)
        0, y, dstW, 1                                                // dst (Zeile)
      );
    }

    // Animation
    let raf = null, t0 = performance.now();
    function frame(now){
      const t = (now - t0) * 0.001; // Sekunden

      // Low-Res-Buffer komplett neu zeichnen
      const cover = computeCoverRect(img.naturalWidth, img.naturalHeight, buf.width, buf.height);
      // optional: leichte Abdunkelung als Grund
      bufx.fillStyle = '#0a0c20';
      bufx.fillRect(0,0,buf.width,buf.height);

      for (let y=0; y<buf.height; y++){
        drawWaveRow(y, t, cover);
      }

      // Buffer → Hauptcanvas „cover“-skaliert, ohne Smoothing ⇒ Pixel-Look
      const W = canvas.width, H = canvas.height, sR = buf.width/buf.height;
      let dw=W, dh=Math.round(W/sR); if(dh < H){ dh=H; dw=Math.round(H*sR); }
      const dx=Math.round((W-dw)/2), dy=Math.round((H-dh)/2);

      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(buf, 0,0, buf.width,buf.height, dx,dy,dw,dh);

      raf = requestAnimationFrame(frame);
    }

    function start(){
      if(!raf) raf = requestAnimationFrame(frame);
    }
  })();
  </script>
</body>
</html>
