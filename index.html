<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>alexhatchl — kinetic grid</title>
<link href="https://fonts.googleapis.com/css2?family=Work+Sans:wght@600;800&family=Inter:wght@600&display=swap" rel="stylesheet">
<style>
  html,body{height:100%;margin:0;background:#f4f4f4;overflow:hidden}

  /* Pixel-Grid (hinterer Layer) */
  canvas#stage{
    position:fixed; inset:0; width:100vw; height:100vh; z-index:1;
    image-rendering:pixelated; image-rendering:crisp-edges; display:block;
  }
  /* UI/Text (glatt) */
  canvas#ui{
    position:fixed; inset:0; width:100vw; height:100vh; z-index:2;
    display:block; pointer-events:none;
  }

  /* Gemeinsame Legend-Stile */
  .legend {
    color:#fff; background:rgba(30,30,30,.15); /* 15% idle */
    border-radius:10px; padding:5px 10px; 
    font:11px/1 "Work Sans",system-ui,sans-serif;
    backdrop-filter:blur(2px);
    display:flex; gap:12px; align-items:center; user-select:none;
    transition:background-color .2s ease;
  }
  .legend.active, .legend:hover { background:rgba(30,30,30,.45); } /* 45% bei Hover/Activity */

  /* Funktions-Legend: links unten (nur Startseite sichtbar) */
  #legend-keys{
    position:fixed; left:12px; bottom:12px; z-index:8;
  }
  /* Arrow-Legend: unten mittig (immer sichtbar) */
  #legend-arrows{
    position:fixed; left:50%; bottom:12px; transform:translateX(-50%); z-index:8;
  }

  .keys{display:inline-flex;gap:4px;align-items:center}
  .key{
    min-width:14px;height:14px;padding:0 4px;
    border:1px solid rgba(255,255,255,.4);
    border-radius:3px;
    display:inline-flex;align-items:center;justify-content:center;
    font:10px/1 "Inter",system-ui,sans-serif;
    background:rgba(255,255,255,.12)
  }
  .lbl{opacity:.9}

  /* Optional: bei sehr schmalen Screens die Legenden stapeln */
  @media (max-width:520px){
    .legend{gap:8px; padding:4px 8px}
    .key{padding:0 3px}
  }
</style>
</head>
<body>

<canvas id="stage"></canvas>
<canvas id="ui"></canvas>

<!-- Funktions-Legende (nur auf Startseite sichtbar) -->
<div class="legend" id="legend-keys" hidden>
  <span class="keys"><span class="key">Space</span><span class="lbl">Play</span></span>
  <span class="keys"><span class="key">R</span><span class="lbl">Layout</span></span>
  <span class="keys"><span class="key">C</span><span class="lbl">Colors</span></span>
  <span class="keys"><span class="key">B</span><span class="lbl">Pixel</span></span>
  <span class="keys"><span class="key">F</span><span class="lbl">Font</span></span>
  <span class="keys"><span class="key">H</span><span class="lbl">Help</span></span>
</div>

<!-- Arrow-Legende (immer sichtbar) -->
<div class="legend" id="legend-arrows">
  <span class="keys"><span class="key">←</span><span class="key">→</span><span class="lbl">Slides</span></span>
</div>

<script>
(()=>{
  // --------- Canvas Setup ----------
  const stage=document.getElementById('stage');
  const stx=stage.getContext('2d',{alpha:false});
  stx.imageSmoothingEnabled=false;

  const ui=document.getElementById('ui');
  const utx=ui.getContext('2d',{alpha:true});
  utx.imageSmoothingEnabled=true;

  const buf=document.createElement('canvas');
  const btx=buf.getContext('2d',{alpha:false});
  btx.imageSmoothingEnabled=false;

  let PIX=4, paused=false, fontIndex=0;
  const FONTS=[
    `"Work Sans",system-ui,sans-serif`,
    `"Inter",system-ui,sans-serif`
  ];

  function resize(){
    stage.width=window.innerWidth;
    stage.height=window.innerHeight;
    ui.width=stage.width; ui.height=stage.height;
    buf.width=Math.ceil(stage.width/PIX);
    buf.height=Math.ceil(stage.height/PIX);
  }
  window.addEventListener('resize',resize,{passive:true}); resize();

  // --------- Farben ----------
  const COLORS={ white:'#FFFFFF', red:'#E6432E', yellow:'#F4D21F', blue:'#1A3D9A', black:'#111111' };
  const PALETTE=[COLORS.white, COLORS.red, COLORS.yellow, COLORS.blue];
  const pickColor=()=>{
    const r=Math.random();
    return r<.64?COLORS.white : r<.80?COLORS.red : r<.92?COLORS.yellow : COLORS.blue;
  };
  const otherColor=(base)=>{
    const opts=PALETTE.filter(c=>c!==base);
    return opts[(Math.random()*opts.length)|0];
  };

  // --------- Layout & Motion ----------
  let vLines,hLines,vCur,vTarget,hCur,hTarget,cells;
  const MIN_GAP=.08, STEP=.04, COUPLE=.55;
  const clamp=(v,a,b)=>v<a?a:(v>b?b:v);

  function seed(){
    const nV=3+(Math.random()*3|0), nH=3+(Math.random()*3|0);
    const rand=n=>{const s=new Set();while(s.size<n)s.add(Math.round((0.12+Math.random()*0.76)*1000)/1000);return[...s].sort((a,b)=>a-b)};
    vLines=[0,...rand(nV),1];
    hLines=[0,...rand(nH),1];
    vCur=vLines.slice(); vTarget=vLines.slice();
    hCur=hLines.slice(); hTarget=hLines.slice();
    cells=[];
    for(let j=0;j<hLines.length-1;j++){
      const row=[]; for(let i=0;i<vLines.length-1;i++) row.push(pickColor());
      cells.push(row);
    }
    bindTextRow(true); // neu binden + Textfarben setzen
  }
  seed();

  function nudge(target,index,dir){
    const i=index, L=i-1, R=i+1, step=dir*STEP;
    const minX = target[L]+MIN_GAP, maxX = target[R]-MIN_GAP;
    target[i] = clamp(target[i]+step, minX, maxX);
    if(L>0){
      const lmin=target[L-1]+MIN_GAP, lmax=target[i]-MIN_GAP;
      target[L] = clamp(target[L]+step*COUPLE, lmin, lmax);
    }
    if(R<target.length-1){
      const rmin=target[i]+MIN_GAP, rmax=target[R+1]-MIN_GAP;
      target[R] = clamp(target[R]+step*COUPLE, rmin, rmax);
    }
  }

  function recolor(){
    // Farben neu, Textfarben bleiben pro Zelle konsistent → kein Blinken
    for(let j=0;j<cells.length;j++){
      for(let i=0;i<cells[j].length;i++){
        const old = cells[j][i];
        let nxt = pickColor();
        // vermeiden, dass Farbe gleich bleibt (mehr Variation)
        if(nxt===old) nxt = pickColor();
        cells[j][i]=nxt;
        // wenn sich Hintergrundfarbe in der Textreihe ändert → Textfarbe neu wählen (aber fix)
        if(j===textRow){
          textColors[i] = (textColors[i] && textColors[i]!==nxt) ? textColors[i] : pickOtherThan(nxt);
        }
      }
    }
  }

  function beat(){
    if(Math.random()<.5){
      if(vTarget.length>2) nudge(vTarget, 1+(Math.random()*(vTarget.length-2)|0), Math.random()<.5?-1:1);
    }else{
      if(hTarget.length>2) nudge(hTarget, 1+(Math.random()*(hTarget.length-2)|0), Math.random()<.5?-1:1);
    }
    if(Math.random()<.18) recolor();
    if(Math.random()<.9) mutateGroups(); // Gruppen ändern (kein Blinken)
  }

  const lerp=(cur,tgt,k)=>{ for(let i=0;i<cur.length;i++) cur[i]+= (tgt[i]-cur[i])*k; };

  // --------- Text (eine Zeile, Gruppen) ----------
  const WORD='alexhatchl';
  let textRow=0, groups=[], textColors=[];
  function bindTextRow(resetColors=false){
    const rows=hLines.length-1;
    textRow = Math.max(0, Math.min(rows-1, (rows/2)|0)); // mittlere Zeile
    groups = WORD.split('');
    fitGroupsToCols();
    if(resetColors){
      const cols=vLines.length-1;
      textColors = new Array(cols);
      for(let i=0;i<cols;i++){
        const bg = cells[textRow][i];
        textColors[i] = pickOtherThan(bg);
      }
    }
  }
  function pickOtherThan(bg){
    const opts=PALETTE.filter(c=>c!==bg);
    return opts[(Math.random()*opts.length)|0];
  }
  function fitGroupsToCols(){
    const cols=vLines.length-1;
    while(groups.length>cols){
      const i = 1 + (Math.random()*(groups.length-1)|0);
      groups[i-1]+=groups[i]; groups.splice(i,1);
    }
    while(groups.length<cols){
      const idx = groups.findIndex(g=>g.length>1);
      if(idx===-1){ groups.push(''); break; }
      const g=groups[idx], cut=1+(Math.random()*(g.length-1)|0);
      groups.splice(idx,1,g.slice(0,cut),g.slice(cut));
    }
  }
  function mutateGroups(){
    const cols=vLines.length-1;
    if(groups.length<=1 || Math.random()<.5){
      const idxs=[]; for(let i=0;i<groups.length;i++) if(groups[i].length>1) idxs.push(i);
      if(idxs.length){
        const i = idxs[(Math.random()*idxs.length)|0];
        const g = groups[i], cut = 1+(Math.random()*(g.length-1)|0);
        groups.splice(i,1,g.slice(0,cut),g.slice(cut));
      }
    }else if(groups.length>=2){
      const i = 1 + (Math.random()*(groups.length-1)|0);
      groups[i-1]+=groups[i]; groups.splice(i,1);
    }
    fitGroupsToCols();
    // Textfarben-Array ggf. auf neue Spaltenzahl trimmen/erweitern
    const cols2=vLines.length-1;
    if(textColors.length!==cols2){
      const next=new Array(cols2);
      for(let i=0;i<cols2;i++){
        const bg = cells[textRow][i];
        next[i] = textColors[i] && textColors[i]!==bg ? textColors[i] : pickOtherThan(bg);
      }
      textColors=next;
    }
  }

  // --------- Zeichnen ----------
  function draw(){
    const W=buf.width,H=buf.height;
    // Zellen
    btx.fillStyle='#F6F6F6'; btx.fillRect(0,0,W,H);
    for(let j=0;j<hCur.length-1;j++){
      const y0=Math.round(hCur[j]*H), y1=Math.round(hCur[j+1]*H);
      for(let i=0;i<vCur.length-1;i++){
        const x0=Math.round(vCur[i]*W), x1=Math.round(vCur[i+1]*W);
        btx.fillStyle=cells[j][i];
        btx.fillRect(x0,y0,x1-x0,y1-y0);
      }
    }
    // Linien
    const L=Math.max(2, Math.round(Math.min(W,H)*0.008));
    btx.fillStyle=COLORS.black;
    for(let i=0;i<vCur.length;i++){ const x=Math.round(vCur[i]*W)-(L>>1); btx.fillRect(x,0,L,H); }
    for(let j=0;j<hCur.length;j++){ const y=Math.round(hCur[j]*H)-(L>>1); btx.fillRect(0,y,W,L); }

    // Buffer → Screen
    stx.imageSmoothingEnabled=false;
    stx.clearRect(0,0,stage.width,stage.height);
    stx.drawImage(buf,0,0,W,H,0,0,stage.width,stage.height);

    // Glatte Buchstaben (eine Zeile, zentriert in der Zeile; keine Blinkfarbe)
    utx.clearRect(0,0,ui.width,ui.height);
    const cols=vCur.length-1;
    const ry0=Math.round(hCur[textRow]*H), ry1=Math.round(hCur[textRow+1]*H);
    const y0=Math.round(ry0 * (stage.height / H));
    const y1=Math.round(ry1 * (stage.height / H));
    const cy=(y0+y1)>>1;

    const fontPx = Math.max(12, Math.round(Math.min(stage.width,stage.height) * 0.02)); // ~klein
    utx.font = `600 ${fontPx}px ${FONTS[fontIndex]}`;
    utx.textAlign='center'; utx.textBaseline='middle';

    for(let i=0;i<cols;i++){
      const g=groups[i]||''; if(!g) continue;
      const x0b=Math.round(vCur[i]*W), x1b=Math.round(vCur[i+1]*W);
      const x0s=Math.round(x0b * (stage.width / W));
      const x1s=Math.round(x1b * (stage.width / W));
      const cx=(x0s+x1s)>>1;
      // feste, von der Zellenfarbe verschiedene Textfarbe
      const bg=cells[textRow][i];
      let tc=textColors[i];
      if(!tc || tc===bg){ tc = textColors[i] = otherColor(bg); }
      utx.fillStyle = tc;
      utx.fillText(g, cx, cy);
    }
  }

  // --------- Loop mit Beats ----------
  let t0=performance.now(), nextA=0, nextB=0;
  function loop(now){
    if(!paused){
      const t=(now-t0)/1000;
      lerp(vCur,vTarget,.14);
      lerp(hCur,hTarget,.14);
      if(t>=nextA){ beat(); nextA = t + (0.85 + (Math.random()*0.16 - 0.08)); }
      if(t>=nextB){ beat(); nextB = t + (1.35 + (Math.random()*0.22 - 0.11)); }
      draw();
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // --------- Keyboard ----------
  window.addEventListener('keydown', e=>{
    const k=e.key.toLowerCase();
    if(k===' '){ paused=!paused; }
    if(k==='r'){ seed(); }
    if(k==='c'){ recolor(); }
    if(k==='b'){ PIX=(PIX===4)?6:(PIX===6?3:4); resize(); }
    if(k==='f'){ fontIndex=(fontIndex+1)%FONTS.length; }
    if(k==='h'){ alert('Keys: Space, R, C, B, F • Arrows for slides'); }
  });

  // --------- Legenden-Logik ----------
  const legKeys = document.getElementById('legend-keys');
  const legArrows = document.getElementById('legend-arrows');

  function onHash(){
    const h=location.hash||'';
    const isStart = (h==='' || /slide=1\b/i.test(h));
    legKeys.hidden = !isStart; // nur auf Startseite anzeigen
  }
  window.addEventListener('hashchange', onHash);
  onHash();

  // Transparenz: 15% idle, 45% bei Mausaktivität/Hover
  let idleTimer=null;
  const touchActive = ()=>{ 
    [legKeys,legArrows].forEach(el=> el && el.classList.add('active'));
    clearTimeout(idleTimer);
    idleTimer=setTimeout(()=>{
      [legKeys,legArrows].forEach(el=> el && el.classList.remove('active'));
    }, 2000);
  };
  // bei Mausbewegung / Touch
  ['mousemove','touchstart','touchmove'].forEach(evt=>{
    window.addEventListener(evt, touchActive, {passive:true});
  });
  // initial kurz aktiv anzeigen
  touchActive();
})();
</script>
</body>
</html>
