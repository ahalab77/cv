<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>alexhatchl — kinetic grid</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    html,body{height:100%;margin:0;background:#f4f4f4}
    /* Canvas liegt bewusst oben, damit keine dunklen Overlays es verdecken */
    canvas#stage{
      position:fixed; inset:0; width:100vw; height:100vh; z-index:2;
      image-rendering: pixelated; image-rendering: crisp-edges; display:block;
    }
  </style>
</head>
<body>

<canvas id="stage"></canvas>

<script>
(() => {
  // ---------- Bühne ----------
  const view = document.getElementById('stage');
  const vtx  = view.getContext('2d', {alpha:false});
  vtx.imageSmoothingEnabled = false;

  const buf = document.createElement('canvas');
  const btx = buf.getContext('2d', {alpha:false});
  btx.imageSmoothingEnabled = false;

  let PIX = 4, paused = false;

  function resize(){
    view.width  = Math.max(2, Math.floor(window.innerWidth));
    view.height = Math.max(2, Math.floor(window.innerHeight));
    const d = Math.min(view.width, view.height);
    PIX = d < 800 ? 3 : 4;
    buf.width  = Math.ceil(view.width  / PIX);
    buf.height = Math.ceil(view.height / PIX);

    // Sofort sichtbar: Papierweiß + Testbalken
    btx.fillStyle = '#F6F6F6'; btx.fillRect(0,0,buf.width,buf.height);
    btx.fillStyle = '#ff3b30'; btx.fillRect(4,4,Math.min(60,buf.width-8),10);
    vtx.clearRect(0,0,view.width,view.height);
    vtx.drawImage(buf,0,0,buf.width,buf.height,0,0,view.width,view.height);
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // ---------- Farben ----------
  const COLORS = {
    white:'#FFFFFF', red:'#E6432E', yellow:'#F4D21F', blue:'#1A3D9A', black:'#111'
  };
  const PALETTE = [COLORS.white, COLORS.red, COLORS.yellow, COLORS.blue];
  const pickColor = () => {
    const r=Math.random(); return r<.64?COLORS.white:r<.80?COLORS.red:r<.92?COLORS.yellow:COLORS.blue;
  };
  const otherColor = base => {
    const choices = PALETTE.filter(c=>c!==base);
    return choices[(Math.random()*choices.length)|0];
  };

  // ---------- Layout ----------
  let vLines,hLines,vCur,vTarget,hCur,hTarget,cells;
  function seedLayout(){
    const nV = 3 + (Math.random()*3|0);
    const nH = 3 + (Math.random()*3|0);
    const randPos = n=>{
      const s=new Set();
      while(s.size<n){ s.add(Math.round((0.12+Math.random()*0.76)*1000)/1000); }
      return [...s].sort((a,b)=>a-b);
    };
    vLines=[0,...randPos(nV),1]; hLines=[0,...randPos(nH),1];
    vCur=vLines.slice(); vTarget=vLines.slice();
    hCur=hLines.slice(); hTarget=hLines.slice();
    cells=[];
    for(let j=0;j<hLines.length-1;j++){
      const row=[]; for(let i=0;i<vLines.length-1;i++) row.push(pickColor());
      cells.push(row);
    }
    bindTextRow();
  }
  seedLayout();

  // ---------- Dynamische Buchstaben-Gruppen ----------
  const WORD='alexhatchl';
  let textRowIndex=0, groups=[];
  function bindTextRow(){
    const rows = hLines.length-1;
    textRowIndex = Math.max(0, Math.min(rows-1, (rows/2)|0));
    groups = WORD.split('');
    fitGroupsToCols();
  }
  function fitGroupsToCols(){
    const cols = vLines.length-1;
    while(groups.length>cols){
      const i = 1 + (Math.random()*(groups.length-1)|0);
      groups[i-1]+=groups[i]; groups.splice(i,1);
    }
    while(groups.length<cols){
      const idx = groups.findIndex(g=>g.length>1);
      if(idx===-1){ groups.push(''); break; }
      const g=groups[idx], cut=1+(Math.random()*(g.length-1)|0);
      groups.splice(idx,1,g.slice(0,cut),g.slice(cut));
    }
  }
  function mutateGroups(){
    const cols=vLines.length-1;
    if(groups.length<=1 || Math.random()<.5){
      const idxs = groups.map((g,i)=>g.length>1?i:-1).filter(i=>i>=0);
      if(idxs.length){
        const i=idxs[(Math.random()*idxs.length)|0], g=groups[i];
        const cut=1+(Math.random()*(g.length-1)|0);
        groups.splice(i,1,g.slice(0,cut),g.slice(cut));
      }
    }else if(groups.length>=2){
      const i=1+(Math.random()*(groups.length-1)|0);
      groups[i-1]+=groups[i]; groups.splice(i,1);
    }
    fitGroupsToCols();
  }

  // ---------- Mechanik ----------
  const MIN_GAP=.08, STEP=.04, COUPLE=.55, EASE=.14;
  let nextBeatA=0, nextBeatB=0; // triggern sofort

  function clamp(v,a,b){return v<a?a:v>b?b:v;}
  function nudge(target,index,dir){
    const i=index, left=i-1, right=i+1;
    const step=dir*STEP, minX=target[left]+MIN_GAP, maxX=target[right]-MIN_GAP;
    target[i]=clamp(target[i]+step,minX,maxX);
    if(left>0){
      const lmin=target[left-1]+MIN_GAP, lmax=target[i]-MIN_GAP;
      target[left]=clamp(target[left]+step*COUPLE,lmin,lmax);
    }
    if(right<target.length-1){
      const rmin=target[i]+MIN_GAP, rmax=target[right+1]-MIN_GAP;
      target[right]=clamp(target[right]+step*COUPLE,rmin,rmax);
    }
  }
  function beat(){
    if(Math.random()<.5){
      if(vTarget.length>2){ nudge(vTarget, 1+(Math.random()*(vTarget.length-2)|0), Math.random()<.5?-1:1); }
    }else{
      if(hTarget.length>2){ nudge(hTarget, 1+(Math.random()*(hTarget.length-2)|0), Math.random()<.5?-1:1); }
    }
    if(Math.random()<.18) recolor();
    if(Math.random()<.9) mutateGroups();
  }
  function recolor(){
    for(let j=0;j<cells.length;j++)
      for(let i=0;i<cells[j].length;i++)
        if(Math.random()<.28) cells[j][i]=pickColor();
  }

  // ---------- Zeichnen ----------
  function lerpTowards(cur,tgt,k){ for(let i=0;i<cur.length;i++) cur[i]+= (tgt[i]-cur[i])*k; }

  function draw(){
    const W=buf.width,H=buf.height;
    btx.fillStyle='#F6F6F6'; btx.fillRect(0,0,W,H);

    for(let j=0;j<hCur.length-1;j++){
      const y0=Math.round(hCur[j]*H), y1=Math.round(hCur[j+1]*H);
      for(let i=0;i<vCur.length-1;i++){
        const x0=Math.round(vCur[i]*W), x1=Math.round(vCur[i+1]*W);
        btx.fillStyle=cells[j][i];
        btx.fillRect(x0,y0,x1-x0,y1-y0);
      }
    }

    // Textzeile in klein (~8px)
    const cols=vCur.length-1;
    if(groups.length!==cols) fitGroupsToCols();
    const ry0=Math.round(hCur[textRowIndex]*H), ry1=Math.round(hCur[textRowIndex+1]*H);
    const rcy=((ry0+ry1)/2)|0;
    const px=Math.max(6, Math.round(Math.min(W,H)*0.012)); // ~8px
    btx.save();
    btx.imageSmoothingEnabled=false;
    btx.font=`${px}px "Press Start 2P", ui-monospace, monospace`;
    btx.textAlign='center'; btx.textBaseline='middle';
    for(let i=0;i<cols;i++){
      const g=groups[i]||''; if(!g) continue;
      const x0=Math.round(vCur[i]*W), x1=Math.round(vCur[i+1]*W), cx=((x0+x1)/2)|0;
      btx.fillStyle=otherColor(cells[textRowIndex][i]);
      btx.fillText(g,cx,rcy);
    }
    btx.restore();

    // Linien
    const L=Math.max(2, Math.round(Math.min(W,H)*0.008));
    btx.fillStyle=COLORS.black;
    for(let i=0;i<vCur.length;i++){ const x=Math.round(vCur[i]*W)- (L>>1); btx.fillRect(x,0,L,H); }
    for(let j=0;j<hCur.length;j++){ const y=Math.round(hCur[j]*H)- (L>>1); btx.fillRect(0,y,W,L); }

    // Buffer → Viewport
    vtx.imageSmoothingEnabled=false;
    vtx.clearRect(0,0,view.width,view.height);
    vtx.drawImage(buf,0,0,W,H,0,0,view.width,view.height);
  }

  // ---------- Loop ----------
  let t0=performance.now();
  function loop(now){
    if(!paused){
      const t=(now-t0)/1000;
      lerpTowards(vCur,vTarget,.14);
      lerpTowards(hCur,hTarget,.14);
      if(t>=nextBeatA){ beat(); nextBeatA = t + (0.85 + (Math.random()*0.16 - 0.08)); }
      if(t>=nextBeatB){ beat(); nextBeatB = t + (1.38 + (Math.random()*0.22 - 0.11)); }
      draw();
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ---------- Shortcuts ----------
  window.addEventListener('keydown', (e)=>{
    const k=e.key.toLowerCase();
    if(k===' ') paused=!paused;
    if(k==='r') seedLayout();
    if(k==='c') recolor();
    if(k==='b'){
      PIX = (PIX===4)?6:(PIX===6?3:4);
      buf.width=Math.ceil(view.width/PIX); buf.height=Math.ceil(view.height/PIX);
    }
  });
})();
</script>

</body>
</html>
