<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://webslides.tv/static/css/webslides.css">
  <link rel="stylesheet" href="https://webslides.tv/static/css/svg-icons.css">
  <title>alexhatchl — portfolio</title>
</head>
<body>
<main role="main">
  <article id="webslides">
   <section class="fullscreen aligncenter" id="pixel-rain-intro">
  <style>
    #pixel-rain-intro { background:#fff; }
    #pixel-rain-intro .stage{
      position:absolute; inset:0; width:100%; height:100%;
      display:block; image-rendering:pixelated; image-rendering:crisp-edges;
    }
    #pixel-rain-intro .overlay{
      position:relative; z-index:3; height:100%;
      display:grid; place-items:center; color:#000;
    }
    #pixel-rain-intro h1{ margin:0; font-size:4rem; letter-spacing:.06em; }
    #pixel-rain-intro .loading{
      position:absolute; bottom:24px; left:24px; color:#666; font-size:.9rem; z-index:4;
    }
    @media (max-width:720px){ #pixel-rain-intro h1{ font-size:2.6rem; } }
  </style>

  <canvas class="stage" id="px-bg"></canvas>
  <canvas class="stage" id="px-rain" style="z-index:2;"></canvas>
  <div class="overlay"><h1>alexhatchl</h1></div>
  <div class="loading" id="px-load">lädt…</div>

  <script>
  (function(){
    const section = document.getElementById('pixel-rain-intro');
    const bg = document.getElementById('px-bg'), rg = document.getElementById('px-rain');
    const bgx = bg.getContext('2d', {alpha:false}), rgx = rg.getContext('2d', {alpha:true});
    bgx.imageSmoothingEnabled = false; rgx.imageSmoothingEnabled = false;

    // === Settings (deine) ===
    const PIX_WIDTH = 320;
    const CONTRAST  = 0.95;
    const PALETTE   = [0,85,170,255];
    const SOURCE    = 'images/window-city.jpg?v=' + Date.now(); // Cache-Buster

    // Performance: interne Renderauflösung (0.6 = 60% der CSS-Größe)
    const INTERNAL_SCALE = 0.6;

    // Helpers
    const clamp=(v,mi,ma)=>v<mi?mi:v>ma?ma:v;
    const contrast=(v,c)=>clamp((v-128)*c+128,0,255);
    const nearest4=g=>PALETTE.reduce((a,p)=>Math.abs(p-g)<Math.abs(a-g)?p:a,PALETTE[0]);

    // Canvas resize (debounced)
    let resizeTimer=null;
    function fitCanvases(){
      const r = section.getBoundingClientRect();
      const W = Math.max(2, Math.floor(r.width));
      const H = Math.max(2, Math.floor(r.height));
      // CSS-Größe bleibt 100%; interne Größe reduziert:
      bg.width = Math.floor(W*INTERNAL_SCALE);
      bg.height= Math.floor(H*INTERNAL_SCALE);
      rg.width = Math.floor(W*INTERNAL_SCALE);
      rg.height= Math.floor(H*INTERNAL_SCALE);
      // Sofort weiß füllen
      bgx.fillStyle = '#fff'; bgx.fillRect(0,0,bg.width,bg.height);
      // Re-Render BG nach Resize (debounced)
      if (img.complete){
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(renderBackground, 120);
      }
    }

    new ResizeObserver(()=>fitCanvases()).observe(section);
    fitCanvases();

    // Bild laden -> Pixel-Art rendern
    const img = new Image();
    img.onload = ()=>{ renderBackground(); pxload.style.display='none'; };
    img.onerror = ()=>{ pxload.textContent = 'Bild nicht gefunden: images/window-city.jpg'; };
    img.src = SOURCE;
    const pxload = document.getElementById('px-load');

    function renderBackground(){
      const ratio = img.height/img.width;
      const w = PIX_WIDTH, h = Math.round(w*ratio);
      const small = document.createElement('canvas');
      small.width = w; small.height = h;
      const sx = small.getContext('2d'); sx.imageSmoothingEnabled = false;
      sx.drawImage(img,0,0,w,h);
      const id = sx.getImageData(0,0,w,h), d = id.data;
      for (let i=0;i<d.length;i+=4){
        let g = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
        g = contrast(g, CONTRAST);
        const q = nearest4(g);
        d[i]=d[i+1]=d[i+2]=q; d[i+3]=255;
      }
      sx.putImageData(id,0,0);
      drawCover(bgx, small);
    }

    function drawCover(ctx, src){
      const W = ctx.canvas.width, H = ctx.canvas.height;
      const sw=src.width, sh=src.height, sR=sw/sh, tR=W/H;
      let dw=W, dh=Math.round(W/sR);
      if (dh<H){ dh=H; dw=Math.round(H*sR); }
      const dx=Math.round((W-dw)/2), dy=Math.round((H-dh)/2);
      ctx.imageSmoothingEnabled=false;
      ctx.fillStyle='#fff'; ctx.fillRect(0,0,W,H);
      ctx.drawImage(src,0,0,sw,sh,dx,dy,dw,dh);
    }

    // === Regen (ohne Fog-Overlay) ===
    let COLS = 64; // Basis
    let streaks = [];
    function buildRain(){
      const W = rg.width; // interne Breite!
      // Dichte adaptiv: ~eine Säule pro ~18px CSS → geteilt durch INTERNAL_SCALE
      COLS = clamp(Math.round((W/INTERNAL_SCALE)/18), 36, 120);
      streaks = Array.from({length:COLS}, (_,i)=>({
        xNorm:(i+Math.random()*0.5)/COLS,
        y: Math.random(),
        v: 0.12 + Math.random()*0.28,    // etwas schneller
        len: 0.06 + Math.random()*0.22,  // längere Läufer
        wob: Math.random()*0.5 + 0.15
      }));
    }
    buildRain();

    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.05, (now - last)/1000); last = now; // max 50ms
      const W = rg.width, H = rg.height;
      rgx.clearRect(0,0,W,H);
      rgx.fillStyle='#000';
      for (const s of streaks){
        const x = Math.round(s.xNorm*W + Math.sin(now*0.0009 + s.xNorm*10)*s.wob*6*INTERNAL_SCALE);
        const y = s.y * H;
        const L = Math.round(s.len * H);
        for (let k=0;k<L;k+=2){
          const yy = (y + k)|0;
          if (yy>=0 && yy<H){
            rgx.fillRect(x, yy, 1, 1);
            if ((k % 6)===0){
              if (x+1 < W) rgx.fillRect(x+1, yy, 1, 1);
              if (x-1 >=0) rgx.fillRect(x-1, yy, 1, 1);
            }
          }
        }
        // Tropfen-Kopf
        rgx.fillRect(x-1, (y+L+1)|0, 3, 2);
        // Bewegung per dt
        s.y += s.v * dt;
        if (s.y * H > H + 12){
          s.y = -Math.random()*0.2;
          s.len = 0.06 + Math.random()*0.22;
          s.v   = 0.12 + Math.random()*0.28;
        }
      }
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // Rebuild Rain bei Resize (debounced)
    let rebuildTimer=null;
    function onResize(){
      fitCanvases();
      clearTimeout(rebuildTimer);
      rebuildTimer = setTimeout(()=>{ buildRain(); if (img.complete) renderBackground(); }, 120);
    }
    document.addEventListener('ws:slide-change', onResize);
    window.addEventListener('resize', onResize, {passive:true});
  })();
  </script>
</section>

  </article>
</main>
<script src="https://webslides.tv/static/js/webslides.js"></script>
<script>window.ws=new WebSlides();</script>
<script defer src="https://webslides.tv/static/js/svg-icons.js"></script>
</body>
</html>
