<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>alexhatchl — kinetic grid</title>
  <!-- pixelige Schrift -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    html,body{height:100%;margin:0;background:#f4f4f4}
    canvas#stage{
      position:fixed; inset:0; width:100vw; height:100vh;
      image-rendering: pixelated; image-rendering: crisp-edges; display:block;
    }
  </style>
</head>
<body>

<canvas id="stage"></canvas>

<script>
(() => {
  // ===== Bühne & Pixel-Buffer =====
  const view  = document.getElementById('stage');
  const vtx   = view.getContext('2d', {alpha:false, desynchronized:true});
  vtx.imageSmoothingEnabled = false;

  const buf   = document.createElement('canvas');
  const btx   = buf.getContext('2d', {alpha:false});
  btx.imageSmoothingEnabled = false;

  let PIX = 4;            // Pixelgröße (Raster-Look)
  let paused = false;

  function resize(){
    view.width  = Math.max(2, Math.floor(window.innerWidth));
    view.height = Math.max(2, Math.floor(window.innerHeight));
    const d = Math.min(view.width, view.height);
    PIX = d < 800 ? 3 : 4;
    buf.width  = Math.ceil(view.width  / PIX);
    buf.height = Math.ceil(view.height / PIX);
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // ===== Farbpalette =====
  const COLORS = {
    white:  '#FFFFFF',
    red:    '#E6432E',
    yellow: '#F4D21F',
    blue:   '#1A3D9A',
    black:  '#111111'
  };
  const PALETTE = [COLORS.white, COLORS.red, COLORS.yellow, COLORS.blue];

  function pickColor(){
    const r = Math.random();
    if (r < 0.64) return COLORS.white;
    if (r < 0.80) return COLORS.red;
    if (r < 0.92) return COLORS.yellow;
    return COLORS.blue;
  }
  function otherColor(base){
    // wähle eine Palettenfarbe, die NICHT base ist
    const choices = PALETTE.filter(c => c !== base);
    return choices[(Math.random() * choices.length) | 0];
  }

  // ===== Layout (Linien, Zellen) =====
  let vLines, hLines, vCur, vTarget, hCur, hTarget, cells;

  function seedLayout(){
    const nV = 3 + Math.floor(Math.random()*3); // 3..5 Zwischenräume
    const nH = 3 + Math.floor(Math.random()*3);

    const randPos = (n) => {
      const s = new Set();
      while (s.size < n){
        const x = 0.12 + Math.random()*0.76;
        s.add(Math.round(x*1000)/1000);
      }
      return Array.from(s).sort((a,b)=>a-b);
    };
    vLines = [0, ...randPos(nV), 1];
    hLines = [0, ...randPos(nH), 1];
    vCur = vLines.slice(); vTarget = vLines.slice();
    hCur = hLines.slice(); hTarget = hLines.slice();

    // Zellenfarben
    cells = [];
    for (let j=0; j<hLines.length-1; j++){
      const row = [];
      for (let i=0; i<vLines.length-1; i++){
        row.push(pickColor());
      }
      cells.push(row);
    }

    // Textzeile neu binden
    bindTextRow();
  }

  function recolor(){
    for (let j=0; j<cells.length; j++){
      for (let i=0; i<cells[j].length; i++){
        if (Math.random() < 0.28) cells[j][i] = pickColor();
      }
    }
  }

  seedLayout();

  // ===== Mechanischer Takt (gekoppelt) =====
  const MIN_GAP = 0.08;
  const STEP    = 0.04;
  const COUPLE  = 0.55;
  const EASE    = 0.14;

  let nextBeatA = 0, nextBeatB = 0;

  function nudge(target, index, dir){
    const i = index;
    const left  = i-1, right = i+1;
    const minX = target[left]  + MIN_GAP;
    const maxX = target[right] - MIN_GAP;
    const step = dir * STEP;
    target[i] = clamp(target[i] + step, minX, maxX);
    if (left>0){
      const lmin = target[left-1] + MIN_GAP;
      const lmax = target[i]      - MIN_GAP;
      target[left] = clamp(target[left] + step*COUPLE, lmin, lmax);
    }
    if (right < target.length-1){
      const rmin = target[i]       + MIN_GAP;
      const rmax = target[right+1] - MIN_GAP;
      target[right] = clamp(target[right] + step*COUPLE, rmin, rmax);
    }
  }

  function beat(){
    // verschiebe zufällig eine vertikale oder horizontale Linie
    if (Math.random() < 0.5){
      if (vTarget.length>2){
        const idx = 1 + Math.floor(Math.random()*(vTarget.length-2));
        const dir = Math.random()<0.5 ? -1 : 1;
        nudge(vTarget, idx, dir);
      }
    } else {
      if (hTarget.length>2){
        const idx = 1 + Math.floor(Math.random()*(hTarget.length-2));
        const dir = Math.random()<0.5 ? -1 : 1;
        nudge(hTarget, idx, dir);
      }
    }
    // gelegentlich Farben auffrischen
    if (Math.random() < 0.18) recolor();
    // und Textgruppen variieren
    if (Math.random() < 0.9) mutateGroups();
  }

  // ===== „alexhatchl“ in dynamischen Gruppen entlang einer Zeile =====
  const WORD = 'alexhatchl';
  let textRowIndex = 0;     // welche Zeile (0..rows-1) – wird bei Layout neu gebunden
  let groups = [];          // Array<string> – z. B. ["al","e","x","ha","t","chl"]

  function bindTextRow(){
    // nimm mittlere Zeile
    const rows = hLines.length - 1;
    textRowIndex = Math.max(0, Math.min(rows-1, Math.floor(rows/2)));
    // initiale Gruppierung: grob in Singles
    groups = WORD.split('');
    fitGroupsToCols();
  }

  function fitGroupsToCols(){
    const cols = vLines.length - 1;
    // zu viele Gruppen → zusammenführen
    while (groups.length > cols){
      // merge zwei benachbarte zufällig
      const i = 1 + Math.floor(Math.random() * (groups.length-1));
      groups[i-1] = groups[i-1] + groups[i];
      groups.splice(i,1);
    }
    // zu wenige Gruppen → irgendwo splitten
    while (groups.length < cols){
      // wähle eine Gruppe mit len>1
      const idx = groups.findIndex(g => g.length>1);
      if (idx === -1){ groups.push(''); break; }
      const g = groups[idx];
      const cut = 1 + Math.floor(Math.random()*(g.length-1));
      const a = g.slice(0,cut), b = g.slice(cut);
      groups.splice(idx,1,a,b);
    }
  }

  function mutateGroups(){
    const cols = vLines.length - 1;
    if (groups.length <= 1 || Math.random()<0.5){
      // splitte eine zufällige Gruppe (mit Länge>1)
      const idxs = groups.map((g,i)=>g.length>1?i:-1).filter(i=>i>=0);
      if (idxs.length){
        const i = idxs[(Math.random()*idxs.length)|0];
        const g = groups[i];
        const cut = 1 + Math.floor(Math.random()*(g.length-1));
        const a = g.slice(0,cut), b = g.slice(cut);
        groups.splice(i,1,a,b);
      }
    } else {
      // merge zwei benachbarte
      if (groups.length>=2){
        const i = 1 + Math.floor(Math.random()*(groups.length-1));
        groups[i-1] = groups[i-1] + groups[i];
        groups.splice(i,1);
      }
    }
    fitGroupsToCols();
  }

  // ===== Zeichnen =====
  function clamp(v, a, b){ return v < a ? a : (v > b ? b : v); }
  function lerpTowards(cur, tgt, k){
    for (let i=0; i<cur.length; i++){
      cur[i] += (tgt[i] - cur[i]) * k;
    }
  }

  function draw(){
    const W = buf.width, H = buf.height;
    btx.fillStyle = '#F6F6F6';
    btx.fillRect(0,0,W,H);

    // Flächen
    for (let j=0; j<hCur.length-1; j++){
      const y0 = Math.round(hCur[j]   * H);
      const y1 = Math.round(hCur[j+1] * H);
      for (let i=0; i<vCur.length-1; i++){
        const x0 = Math.round(vCur[i]   * W);
        const x1 = Math.round(vCur[i+1] * W);
        btx.fillStyle = cells[j][i];
        btx.fillRect(x0, y0, x1-x0, y1-y0);
      }
    }

    // Textzeile
    const cols = vCur.length - 1;
    if (groups.length !== cols) fitGroupsToCols();
    const ry0 = Math.round(hCur[textRowIndex]   * H);
    const ry1 = Math.round(hCur[textRowIndex+1] * H);
    const rcy = Math.floor((ry0 + ry1)/2);       // vertikale Mitte der Zeile

    // kleine, kantige Schrift
    const px = Math.max(1, Math.round(Math.min(W,H) * 0.012)); // ~8px auf Desktop
    btx.save();
    btx.imageSmoothingEnabled = false;
    btx.font = `${px}px "Press Start 2P", ui-monospace, monospace`;
    btx.textAlign = 'center';
    btx.textBaseline = 'middle';

    for (let i=0; i<cols; i++){
      const g = groups[i] || '';
      if (!g) continue;
      const x0 = Math.round(vCur[i]   * W);
      const x1 = Math.round(vCur[i+1] * W);
      const cx = Math.floor((x0 + x1)/2);

      // Farbe ≠ Kastenfarbe
      const base = cells[textRowIndex][i];
      btx.fillStyle = otherColor(base);
      btx.fillText(g, cx, rcy);
    }
    btx.restore();

    // Linien
    const L = Math.max(2, Math.round(Math.min(W,H) * 0.008));
    btx.fillStyle = COLORS.black;
    for (let i=0; i<vCur.length; i++){
      const x = Math.round(vCur[i] * W) - Math.floor(L/2);
      btx.fillRect(x, 0, L, H);
    }
    for (let j=0; j<hCur.length; j++){
      const y = Math.round(hCur[j] * H) - Math.floor(L/2);
      btx.fillRect(0, y, W, L);
    }

    // Buffer → Viewport
    vtx.imageSmoothingEnabled = false;
    vtx.clearRect(0,0,view.width,view.height);
    vtx.drawImage(buf, 0,0, W,H, 0,0, view.width, view.height);
  }

  // ===== Loop =====
  let t0 = performance.now();
  function loop(now){
    if (!paused){
      const t = (now - t0)/1000;
      lerpTowards(vCur, vTarget, EASE);
      lerpTowards(hCur, hTarget, EASE);
      // zwei überlagerte Takte
      if (t >= nextBeatA){ beat(); nextBeatA = t + (0.85 + (Math.random()*0.16 - 0.08)); }
      if (t >= nextBeatB){ beat(); nextBeatB = t + (1.38 + (Math.random()*0.22 - 0.11)); }
      draw();
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ===== Shortcuts (keine Legende angezeigt) =====
  window.addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if (k === ' '){ paused = !paused; }
    if (k === 'r'){ seedLayout(); }
    if (k === 'c'){ recolor(); }
    if (k === 'b'){
      PIX = (PIX === 4) ? 6 : (PIX === 6 ? 3 : 4);
      buf.width  = Math.ceil(view.width  / PIX);
      buf.height = Math.ceil(view.height / PIX);
    }
  });
})();
</script>

</body>
</html>
